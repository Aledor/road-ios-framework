//
//  RFClassGenerator.m
//  AttributedClassGenerator
//
//  Copyright (c) 2014 EPAM Systems, Inc. All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//  Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//  Redistributions in binary form must reproduce the above copyright notice, this
//  list of conditions and the following disclaimer in the documentation and/or
//  other materials provided with the distribution.
//  Neither the name of the EPAM Systems, Inc.  nor the names of its contributors
//  may be used to endorse or promote products derived from this software without
//  specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//  See the NOTICE file and the LICENSE file distributed with this work
//  for additional information regarding copyright ownership and licensing


#import "RFClassGenerator.h"


@implementation RFClassGenerator

static NSString * const kGeneratedFileComment = @"/**\n *This file was generated by AttributedClassGenerator, utility tool for libObjCAttr performance check\n */\n\n";

static NSString * const kAttributeTemplate = @"RF_ATTRIBUTE(AttributeClass%i)\n";

static NSString * const kImportTemplate = @"#import \"%@\"\n";
static NSString * const kFrameworkImportTemplate = @"#import <%@>\n";
static NSString * const kInterfaceTemplate = @"@interface %@ : NSObject\n";
static NSString * const kImplementationIgnoreWarningsStart = @"#pragma clang diagnostic push\n\
#pragma clang diagnostic ignored \"-Wincomplete-implementation\"\n";
static NSString * const kImplementationIgnoreWarningsEnd = @"#pragma clang diagnostic pop\n";
static NSString * const kImplementationTemplate = @"@implementation %@\n";
static NSString * const kEndKeyword = @"@end\n";

static NSString * const kROADAttributeImport = @"ROAD/ROADAttribute.h";

static NSString * const kPropertyTemplate = @"@property (nonatomic) id property%i;\n";
static NSString * const kMethodTemplate = @"- (void)method%i;\n";
static NSString * const kMethodImplTemplate = @"- (void)method%i { }\n";
static NSString * const kIvarBlockTemplate = @"{\n%@}\n";
static NSString * const kIvarTemplate = @"id _ivar%i;\n";

- (BOOL)generateAndSaveClass {
    if (![self createOutputFolder]) {
        return NO;
    }

    [self generateHeaderFile];

    [self generateImplementationFile];

    return YES;
}

- (BOOL)createOutputFolder {
    BOOL success = NO;

    if (![[NSFileManager defaultManager] fileExistsAtPath:self.outputPath]) {
        NSError *error;
        success = [[NSFileManager defaultManager] createDirectoryAtPath:self.outputPath withIntermediateDirectories:YES attributes:nil error:&error];
    }
    else {
        success = YES;
    }

    return success;
}

- (void)generateHeaderFile {
    NSMutableString *headerFileContent = [[NSMutableString alloc] init];
    [headerFileContent appendString:kGeneratedFileComment];

    [headerFileContent appendFormat:kFrameworkImportTemplate, kROADAttributeImport];
    for (NSString *import in self.imports) {
        [headerFileContent appendFormat:kImportTemplate, import];
    }

    if (self.numberOfClassAttributes > 0) {
        for (int attributeIndex = 0; attributeIndex < self.numberOfClassAttributes; attributeIndex++) {
            [headerFileContent appendFormat:kAttributeTemplate, attributeIndex];
        }
    }
    [headerFileContent appendFormat:kInterfaceTemplate, self.className];

    [self generateIvarsInString:headerFileContent];

    [self generatePropertiesInString:headerFileContent];

    [self generateMethodsInString:headerFileContent];

    [headerFileContent appendString:kEndKeyword];

    [self saveString:headerFileContent toFileWithExtesion:@"h"];
}

- (void)generateMethodsInString:(NSMutableString *)headerFileContent {
    for (int methodIndex = 0; methodIndex < self.numberOfMethods; methodIndex++) {
        for (int attributeIndex = 0; attributeIndex < self.numberOfMethodsAttributes; attributeIndex++) {
            [headerFileContent appendFormat:kAttributeTemplate, attributeIndex];
        }
        [headerFileContent appendFormat:kMethodTemplate, methodIndex];
    }
}

- (void)generateIvarsInString:(NSMutableString *)headerFileContent {
    if (self.numberOfIvars > 0) {
        NSMutableString *ivarString = [[NSMutableString alloc] init];
        for (int ivarIndex = 0; ivarIndex < self.numberOfIvars; ivarIndex++) {
            for (int attributeIndex = 0; attributeIndex < self.numberOfIvarsAttributes; attributeIndex++) {
                [ivarString appendFormat:kAttributeTemplate, attributeIndex];
            }
            [ivarString appendFormat:kIvarTemplate, ivarIndex];
        }

        [headerFileContent appendFormat:kIvarBlockTemplate, ivarString];
    }
}

- (void)generatePropertiesInString:(NSMutableString *)headerFileContent {
    for (int propertyIndex = 0; propertyIndex < self.numberOfProperties; propertyIndex++) {
        for (int attributeIndex = 0; attributeIndex < self.numberOfPropertieAttributes; attributeIndex++) {
            [headerFileContent appendFormat:kAttributeTemplate, attributeIndex];
        }
        [headerFileContent appendFormat:kPropertyTemplate, propertyIndex];
    }
}

- (void)generateImplementationFile {
    NSMutableString *implFileContent = [[NSMutableString alloc] init];
    [implFileContent appendString:kGeneratedFileComment];

    [implFileContent appendFormat:kImportTemplate, [NSString stringWithFormat:@"%@.h", self.className]];

    [implFileContent appendString:kImplementationIgnoreWarningsStart];
    [implFileContent appendFormat:kImplementationTemplate, self.className];
    [self generateImplMethodsInString:implFileContent];
    [implFileContent appendString:kEndKeyword];
    [implFileContent appendString:kImplementationIgnoreWarningsEnd];

    [self saveString:implFileContent toFileWithExtesion:@"m"];
}

- (void)generateImplMethodsInString:(NSMutableString *)implFileContent {
    for (int methodIndex = 0; methodIndex < self.numberOfMethods; methodIndex++) {
        [implFileContent appendFormat:kMethodImplTemplate, methodIndex];
    }
}

- (void)saveString:(NSString *)string toFileWithExtesion:(NSString *)extenstion {
    NSString *pathFile = [self.outputPath stringByAppendingPathComponent:self.className];
    pathFile = [pathFile stringByAppendingPathExtension:extenstion];

    NSError *error;
    if (![string writeToFile:pathFile atomically:YES encoding:NSUTF8StringEncoding error:&error]) {
        NSLog(@"%@", error);
    }
}

@end
